"""Utilities for logging computation events via the standard `logging` module.

Functions in this module fall into two categories:

* Functions that convert computation events generated by the `Engine.map`
method to calls to the standard Python `logging` module, using the loggers
in the "yapapi" namespace (e.g. `logging.getLogger("yapapi.runner")`).
These functions should be passed as `event_emitter` arguments to `Engine()`.

* Functions that perform configuration of the `logging` module itself.
Since logging configuration is in general a responsibility of the code that
uses `yapapi` as a library, we only provide the `enable_default_logger`
function in this category, that enables logging to stderr with given level
(`logging.DEBUG` by default).


Functions for handling events
-----------------------------

Several function from this module can be passed as `event_emitter` callback to
`yapapi.runner.Engine()`.

For detailed human-readable output use the `log_event` function:
```
    Engine(..., event_emitter=yapapi.log.log_event)
```
For even more detailed machine-readable output use `log_event_json`:
```
    Engine(..., event_emitter=yapapi.log.log_event_json)
```
For summary human-readable output use `log_summary()`:
```
    Engine(..., event_emitter=yapapi.log.log_summary())
```
Summary output can be combined with a detailed one by passing a detailed logger
as an argument to `log_summary`:
```
    Engine(
        ...
        event_emitter=yapapi.log.log_summary(yapapi.log.log_event_json)
    )
```
"""
from collections import defaultdict
import itertools
import json
import logging
import time
from typing import Any, Callable, Dict, Iterator, List, Optional, Set

from yapapi.runner.events import Event, EventType, event_type_to_string


logger = logging.getLogger("yapapi.runner")


def enable_default_logger(
    format_: str = "[%(asctime)s %(levelname)s %(name)s] %(message)s", level: int = logging.DEBUG
):
    """Enable the default logger that logs messages to stderr."""

    logger = logging.getLogger("yapapi")
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter(format_))
    handler.setLevel(level)
    logger.addHandler(handler)
    logger.setLevel(level)
    logger.disabled = False


def log_event(event: EventType) -> None:
    """Log an event in human-readable format."""

    loglevel = logging.DEBUG

    def _format(obj: Any, max_len: int = 200) -> str:
        # This will also escape control characters, in particular,
        # newline characters in `obj` will be replaced by r"\n".
        text = repr(obj)
        if len(text) > max_len:
            text = text[: max_len - 3] + "..."
        return text

    if not logger.isEnabledFor(loglevel):
        return

    msg = event_type_to_string[type(event)]
    info = "; ".join(f"{name} = {_format(value)}" for name, value in event._asdict().items())
    if info:
        msg += "; " + info
    logger.log(loglevel, msg)


def log_event_json(event: EventType) -> None:
    """Log an event as a tag with attributes in JSON format."""

    info = {name: str(value) for name, value in event._asdict().items()}
    logger.debug("%s %s", type(event).__name__, json.dumps(info) if info else "")


class SummaryLogger:
    """Aggregates information from computation events to provide a high-level description.

    The logger's `log()` method can be used as `event_emitter` callback
    to `Engine()`. It will aggregate the events generated by `Engine.map()`
    and output some summary information.

    The optional `wrapped_emitter` argument can be used for chaining event
    emitters: each event logged with `log()` is first passed to
    `wrapped_emitter`.

    For example, with the following setup, each event emitted by `engine`
    will be logged by `log_event_json`, and additionally, certain events
    will cause summary messages to be logged.
    ```
        detailed_logger = log_event_json
        summary_logger = SummaryLogger(wrapped_emitter=detailed_logger).log
        engine = Engine(..., event_emitter=summary_logger)
    ```
    """

    logger = logging.getLogger("yapapi.summary")

    # Generates subsequent numbers, for use in generated provider names
    numbers: Iterator[int]

    # Start time of the computation
    start_time: float

    # Set of confirmed proposal ids
    confirmed_proposals: Set[str]

    # Maps agreement ids to provider names
    agreement_provider_name: Dict[str, str]

    # Set of agreements confirmed by providers
    confirmed_agreements: Set[str]

    # Maps task id to task data
    task_data: Dict[str, Any]

    # Maps a provide name to the list of task ids computed by the provider
    provider_tasks: Dict[str, List[str]]

    # Map a provider name to the sum of amounts in this provider's invoices
    provider_cost: Dict[str, float]

    # Has computation finished?
    finished: bool

    def __init__(self, wrapped_emitter: Optional[Callable[[EventType], None]] = None):
        """Create a SummaryLogger."""

        self._wrapped_emitter = wrapped_emitter
        self.numbers: Iterator[int] = itertools.count(1)
        self._reset()

    def _reset(self) -> None:
        """Reset all information aggregated by this logger."""

        self.start_time = time.time()
        self.confirmed_proposals = set()
        self.agreement_provider_name = {}
        self.confirmed_agreements = set()
        self.task_data = {}
        self.provider_tasks = defaultdict(list)
        self.provider_cost = {}
        self.finished = False
        self.error_occurred = False

    def _print_total_cost(self) -> None:

        if not self.finished:
            return

        provider_names = set(self.provider_tasks.keys())
        if set(self.provider_cost).issuperset(provider_names):
            total_cost = sum(self.provider_cost.values(), 0.0)
            self.logger.info("Total cost: %s", total_cost)

    def log(self, event: EventType) -> None:
        """Register an event."""

        if self._wrapped_emitter:
            self._wrapped_emitter(event)

        if self.error_occurred:
            return

        try:
            self._handle(event)
        except Exception:
            self.logger.exception("SummaryLogger entered invalid state")
            self.error_occurred = True

    def _handle(self, event: EventType):

        if isinstance(event, Event.ComputationStarted):
            self._reset()

        if isinstance(event, Event.SubscriptionCreated):
            self.logger.info(event_type_to_string[type(event)])

        elif isinstance(event, Event.ProposalConfirmed):
            self.confirmed_proposals.add(event.prop_id)
            self.logger.info(
                "Received proposals from %s providers so far", len(self.confirmed_proposals)
            )

        elif isinstance(event, Event.AgreementCreated):
            provider_name = event.provider_id.name
            if not provider_name:
                provider_name = f"provider-{next(self.numbers)}"
            self.logger.info("Agreement proposed to provider '%s'", provider_name)
            self.agreement_provider_name[event.agr_id] = provider_name

        elif isinstance(event, Event.AgreementConfirmed):
            self.logger.info(
                "Agreement confirmed by provider '%s'", self.agreement_provider_name[event.agr_id]
            )
            self.confirmed_agreements.add(event.agr_id)

        elif isinstance(event, Event.TaskStarted):
            self.task_data[event.task_id] = event.task_data

        elif isinstance(event, Event.ScriptSent):
            provider_name = self.agreement_provider_name[event.agr_id]
            self.logger.info(
                "Task sent to provider '%s', task data: %s",
                provider_name,
                self.task_data[event.task_id],
            )

        elif isinstance(event, Event.ScriptFinished):
            provider_name = self.agreement_provider_name[event.agr_id]
            self.logger.info(
                "Task computed by provider '%s', task data: %s",
                provider_name,
                self.task_data[event.task_id],
            )
            self.provider_tasks[provider_name].append(event.task_id)

        elif isinstance(event, Event.InvoiceReceived):
            provider_name = self.agreement_provider_name[event.agr_id]
            cost = self.provider_cost.get(provider_name, 0.0)
            cost += float(event.amount)
            self.provider_cost[provider_name] = cost
            self._print_total_cost()

        elif isinstance(event, Event.ComputationFinished):
            self.finished = True
            total_time = time.time() - self.start_time
            self.logger.info(f"Computation finished in {total_time:.1f}s")
            self.logger.info(
                "Negotiated agreements with %s providers", len(self.confirmed_agreements)
            )
            for provider_name, tasks in self.provider_tasks.items():
                self.logger.info("Provider '%s' computed %s tasks", provider_name, len(tasks))
            self._print_total_cost()


def log_summary(wrapped_emitter: Optional[Callable[[EventType], None]] = None):
    """Output a summary of computation.

    This is a utility function that creates a `SummaryLogger` instance
    wrapping an optional `wrapped_emitter` and returns its `log` method.

    See the documentation of `SummaryLogger` for more information.
    """
    summary_logger = SummaryLogger(wrapped_emitter)
    return summary_logger.log
